# C02 排序

## 2.1 插入排序

about 插入排序伪代码描述

```
INSERTION-(A)
for j = 2 to A. length
    key= A[j]
    //Insert A[j] into the sorted sequence A[l. . j —1].
    i=j-1
    while i > 0 and A[i] > key
        A[i+1] = A[i]
        i=i-1
    A[i + 1] = key  // key ：希望排序的数
```

about 循环不变式

- 初始化：循环的第一次迭代开始前，它为真
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真
- 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的

> 这类似数学归纳法，其中为了证明某条性质成立，需要证明一个基本情况和一个归纳步。
> 这里，证明第一次迭代之前不变式成立对应于基本情况，证明从一次迭代到下一次迭代不变式成立对应于归纳步。

about 用 循环不变式 来证明 插入排序
- 初始化：
首先证明在第一次循环迭代之前（当 j=2 时），循环不变式成立
气所以子数组
A[l.. j-1]仅由单个元素 A[l]组成，实际上就是 A[l] 中原来的元素。而且该子数组是排序好的
（当然很平凡）。这表明第一次循环迭代之前循环不变式成立。
保持：其次处理第二条性质：证明每次迭代保持循环不变式。非形式化地，
for 循环体的第
4~7 行将 A[j-1] 、
A[j — 2] 、
A[j-3] 等向右移动一个位置，直到找到 A[j] 的适当位置，第 8
行将 A[j] 的值插入该位置。这时子数组 A[l.. j] 由原来在 A[l.. j] 中的元素组成，但已按序排
列。那么对 for 循环的下一次迭代增加］将保持循环不变式。
第二条性质的一种更形式化的处理要求我们对第 5~7 行的 while 循环给出并证明一个循环不
变式。然而，这里我们不愿陷入形式主义的困境，而是依赖以上非形式化的分析来证明第二条性
lliJ
质对外层循环成立。
终止：最后研究在循环终止时发生了什么。导致 for 循环终止的条件是 j>A. length=n 。因
为每次循环迭代］增加 1, 那么必有 j=n+l 。在循环不变式的表述中将］用 n+l 代替，我们有：
子数组 A[l.. n] 由原来在 A[l.. n] 中的元素组成，但已按序排列。注意到，子数组 A[l.. n] 就是整
个数组，我们推断出整个数组已排序。因此算法正确。